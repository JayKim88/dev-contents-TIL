## 브라우저의 기본 구조

1. 사용자 인터페이스 - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. 렌더링 엔진 - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
   - 렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다.
   - 파이어폭스와 크롬, 사파리는 두 종류의 렌더링 엔진으로 제작되었다. 파이어폭스는 모질라에서 직접 만든 게코(Gecko) 엔진을 사용하고 사파리와 크롬은 웹킷(Webkit) 엔진을 사용한다.
   - 렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.
4. 통신 - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. 자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행.
7. 자료 저장소 - 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '[웹 데이터 베이스](http://www.html5rocks.com/en/features/storage)'가 정의되어 있다.

<img width="600" alt="Screenshot 2023-10-15 at 10 52 58 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/3ecdcb74-0c51-40be-925a-148e709944a7">

## 브라우저의 렌더링 프로세스

1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
   - 서버에 요청을 전송하기 위해 브라우저는 주소 창을 제공한다.
   - 브라우저의 주소창에 URL을 입력하고 엔터 키를 누르면 URL의 호스트 이름   이 DNS  를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에게 요청을 전송한다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.

   a. HTML 파싱과 DOM 생성

   서버로부터 응답 받은 HTML 문서는 문자열로 이루어진 순수한 텍스트이므로, 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체) 로 변환하여 메모리에 저장해야 한다. 각 토큰을 객체로 변환하여 노드들을 생성한다. **즉, DOM 은 HTML 문서를 파싱한 결과물이다.**

      <img width="800" alt="Screenshot 2023-10-15 at 10 52 39 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/e2d53836-211f-4856-938b-e061e0cbce1e">

   b. CSS 파싱과 CSSOM 생성

   1. link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일 이나

   2. style 태그 내의 CSS 를 HTML 과 동일한 파싱 과정(바이트-> 문자 -> 토큰 -> 노드 -> CSSOM) 을 통해 CSS Object Model 을 생성한다.

   <img width="800" alt="Screenshot 2023-10-15 at 10 53 12 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/057bf491-acba-4384-828e-60b7c5f23137">

   c. 렌더 트리 생성

   렌더 트리는 각 HTML 요소의 레이아웃(위치와 크기) 을 계산하는 데 사용되고 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.

    <img width="800" alt="Screenshot 2023-10-15 at 10 53 31 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/b69b32f4-3118-4ae5-af93-d8e2e11398c2">

   #### 스타일 계산

   렌더 트리를 구축하려면 각 렌더 객체의 시각적 속성에 대한 계산이 필요한데 이것은 각 요소의 스타일 속성을 계산함으로써 처리된다.

   스타일은 인라인 스타일 요소와 HTML의 시각적 속성(예를 들면 bgcolor 같은 HTML 속성)과 같은 다양한 형태의 스타일 시트를 포함하는데 HTML의 시각적 속성들은 대응하는 CSS 스타일 속성으로 변환된다.

   - 스타일을 계산하는 일에는 다음과 같은 몇 가지 어려움이 따른다.

     1. 스타일 데이터는 구성이 매우 광범위한데 수 많은 스타일 속성들을 수용하면서 메모리 문제를 야기할 수 있다.
     2. 최적화되어 있지 않다면 각 요소에 할당된 규칙을 찾는 것은 성능 문제를 야기할 수 있다. 각 요소에 할당된 규칙 목록을 전체 규칙으로부터 찾아내는 것은 과중한 일이다. 맞는 규칙을 찾는 과정은 얼핏 보기에는 약속된 방식으로 순탄하게 시작하는 것 같지만 실상 쓸모가 없거나 다른 길을 찾아야만 하는 복잡한 구조가 될 수 있다.

        예를 들어 이런 복합 선택자가 있다.

        div div div div { … }

        이 선택자는 3번째 자손 `div` 에 규칙을 적용한다는 뜻이다. 규칙을 적용할 `div` 요소를 확인하려면 트리로부터 임의의 줄기를 선택하고 탐색하는 과정에서 규칙에 맞지 않는 줄기를 선택했다면 또 다른 줄기를 선택해야 한다.

     3. 규칙을 적용하는 것은 계층 구조를 파악해야 하는 꽤나 복잡한 다단계 규칙을 수반한다.

   - 해결 방법
     스타일 정보 공유
     : 웹킷 노드는 스타일 객체(RenderStyle)를 참조하는데 이 객체는 일정 조건 아래 공유할 수 있다. 노드가 형제이거나 또는 사촌일 때 공유하며 다음과 같은 조건일 때 공유할 수 있다.
     1. 동일한 마우스 반응 상태를 가진 요소여야 한다. 예를 들어 한 요소가 :hover 상태가 될 수 없는데 다른 요소는 :hover가 될 수 있다면 동일한 마우스 상태가 아니다.
     2. 아이디가 없는 요소.
     3. 태그 이름이 일치해야 한다.
     4. 클래스 속성이 일치해야 한다.
     5. 지정된 속성이 일치해야 한다.
     6. 링크(link) 상태가 일치해야 한다.
     7. 초점(focus) 상태가 일치해야 한다.
     8. 문서 전체에서 속성 선택자의 영향을 받는 요소가 없어야 한다. 여기서 영향이라 함은 속성 선택자를 사용한 경우를 말한다(속성 선택자 예 `input[type=text]{...}`)
     9. 요소에 인라인 스타일 속성이 없어야 한다(인라인 스타일 예 `<p style="...">...</p>`).
     10. 문서 전체에서 형제 선택자를 사용하지 않아야 한다. 웹 코어는 형제 선택자를 만나면 전역 스위치를 열고 전체 문서의 스타일 공유를 중단한다. 형제 선택자는 + 선택자와 :first-child 그리고 :last-child를 포함한다.

3. 브라우저의 자바스크립트 엔진은

   1. 서버로부터 응답된 자바스크립트를 파싱하여 추상적 구문 트리(Abstract Syntax Tree)를 생성하고, 이를 기반으로
   2. 인터프리터(즉 CPU)가 실행할 수 있는 중간 코드인 바이트코드로 변환하여 실행한다.
   3. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.

   <img width="800" alt="Screenshot 2023-10-15 at 10 54 07 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/fe405032-ad2d-44b8-85af-a6a50653714f">

4. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.

   리플로우와 리페인트

   - 리플로우는 레이아웃 계산을 다시하는 것으로 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우 실행된다.
   - 리페인트는 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다.

   <img width="800" alt="Screenshot 2023-10-15 at 10 53 57 PM" src="https://github.com/JayKim88/dev-contents-TIL/assets/55373668/b7a5314f-80ed-4773-b98b-f25afe6838e3">

**_주의_**

자바스크립트가 실행될 시점에는 이미 렌더링 엔진이 HTML 요소를 모두 파싱하여 DOM 생성을 완료한 이후여야 한다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하는 에러가 발생할 우려도 없다. 또한 자바스크립트가 실행되기 이전에 DOM 생성이 완료되어 렌더링되므로 페이지 로딩 시간이 단축되는 이점도 있다.

### 용어 정리

**토크나이징\_tokenizing**

단순한 문자열인 자바스크립트 소스코드를 어휘 분석\_lexical analysis 하여 문법적 의미를 갖는 코드의 최소 단위인 토큰\_token들로 분해한다. 이 과정을 렉싱\_lexing이라고 부르기도 하지만 토크나이징과 미묘한 차이가 있다.

**파싱\_parsing**

토큰들의 집합을 구문 분석\_syntactic analysis하여 ASTAbstract Syntax Tree(추상적 구문 트리)를 생성한다. AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조다.

**바이트코드 생성과 실행**

파싱의 결과물로서 생성된 AST는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행된다.
